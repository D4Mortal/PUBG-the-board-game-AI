# Chirag Rao Sahib      : 836011
# Daniel Hao            : 834496
# Date                  : 30/03/2018

##############################Question 1#######################################

For calculating the number of available moves, what is the time complexity and
space complexity of your program? You should not count the time taken to read
the board configuration from input.

/////////////////////////////Answer////////////////////////////////////////////

To reduce redundancy in our code we simply sum over the number of legal moves
for each white (or black) piece. (This is also used in calculating the
sequence) For each actual piece on the board, the function getLegalMoves()
tests all possible directions (8 including jumps) for legality. The max number
of legal moves a piece may make (for any configuration) is 4, including jumps.
(the loop in moveCount())

As per the lectures time complexity can be measured in terms of the number of
‘nodes’ (in this case moves) expanded or tested. Considering the above:
- We must repeat every step twice (black and white counts)
- First find the actual pieces on the board (64)
- A maximum of 12 pieces per player may be present on the board at any given
    time
- Then testing each direction for legality (max 12 pieces), adds another
    factor of 8
- Multiplied by another factor of 4, when summing over the max number of
    legal moves

Hence the worst case number of comparisons or ‘move tests’ necessary is:
T(n) = 2 * [ 64 + 12 * 8 ] * 4 =  1280
where T(n) is the number of operations

Since the board size is constant, the value of T(n) is independent of any
input size (n) and thus the time complexity is considered to be constant
or O(1).

As per the lectures, space complexity can be measured in terms of the number
of ‘nodes’ (in this case symbols) stored. In the initial stages we necessarily
read every symbol of the board into a list of lists. The number of symbols
stored is equal to 8 * 8 = 64. As the function getLegalMoves() is also used in
calculating the sequence, it stores a dictionary of legal actions each white
piece may take. (unnecessary for this stage). There exists some maximum for
the number of actions stored, however the worst case complexity is constant
since the board size does not change. Following similar reasoning above, the
space complexity can also be shown to be O(1).

##############################Question 2#######################################

For calculating the sequence of moves to eliminate all enemy pieces, how have
you modelled the problem as a search problem? What search algorithm does your
program use? If applicable, what is the branching factor of your search tree?
What is the maximum search depth? Does your algorithm always return the
shortest possible sequence of moves that will eliminate all enemy pieces?

/////////////////////////////Answer////////////////////////////////////////////













###############################################################################
