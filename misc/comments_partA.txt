# Chirag Rao Sahib      : 836011
# Daniel Hao            : 834496
# Date                  : 30/03/2018

##############################Question 1#######################################

For calculating the number of available moves, what is the time complexity and
space complexity of your program? You should not count the time taken to read
the board configuration from input.

/////////////////////////////Answer////////////////////////////////////////////

To reduce redundancy in our code we simply sum over the number of legal moves
for each white (or black) piece. (This is also used in calculating the
sequence) For each actual piece on the board, the function getLegalMoves()
tests all possible directions (8 including jumps) for legality. The max number
of legal moves a piece may make (for any configuration) is 4, including jumps.
(the loop in moveCount())

As per the lectures time complexity can be measured in terms of the number of
‘nodes’ (in this case moves) expanded or tested. Considering the above:
- We must repeat every step twice (black and white counts)
- First find the actual pieces on the board (64)
- A maximum of 12 pieces per player may be present on the board at any given
    time
- Then testing each direction for legality (max 12 pieces), adds another
    factor of 8
- Multiplied by another factor of 4, when summing over the max number of
    legal moves

Hence the worst case number of comparisons or ‘move tests’ necessary is:
T(n) = 2 * [ 64 + 12 * 8 ] * 4 =  1280
where T(n) is the number of operations

Since the board size is constant, the value of T(n) is independent of any
input size (n) and thus the time complexity is considered to be constant
or O(1).

As per the lectures, space complexity can be measured in terms of the number
of ‘nodes’ (in this case symbols) stored. In the initial stages we necessarily
read every symbol of the board into a list of lists. The number of symbols
stored is equal to 8 * 8 = 64. As the function getLegalMoves() is also used in
calculating the sequence, it stores a dictionary of legal actions each white
piece may take. (unnecessary for this stage). There exists some maximum for
the number of actions stored, however the worst case complexity is constant
since the board size does not change. Following similar reasoning above, the
space complexity can also be shown to be O(1).

##############################Question 2#######################################

For calculating the sequence of moves to eliminate all enemy pieces, how have
you modelled the problem as a search problem? What search algorithm does your
program use? If applicable, what is the branching factor of your search tree?
What is the maximum search depth? Does your algorithm always return the
shortest possible sequence of moves that will eliminate all enemy pieces?

/////////////////////////////Answer////////////////////////////////////////////

We modelled the problem as a search problem by assigning a single node to
represent each possible board configuration (state space). As we traverse down
the search tree, each node is generated by applying some action (move) to it’s
parent node. At the root of the search tree is the initial board state
(retrieved from standard input) and the goal node is a board state in which
all black pieces have been eliminated (goal test). The path cost is the number
of moves required to generate a given node. A solution is a sequence of
actions (moves) from the initial state to the goal state.

The search algorithm used is A* search with Manhattan distance as the main
heuristic (h(n)) to estimate, f(n)=g(n) +h(n), the least-cost path from the
initial node to the goal node.

Under the assumption given in partA-submit, there is a maximum of 5 white
pieces which can be moved. As mentioned in the first question each piece can
make a maximum of 4 moves. Each state is generated by a single action being
applied, thus the maximum number of successor states for a node is 5 * 4 = 20.
I.e. The branching factor of the search tree is 20 (b = 20).

The maximum search depth, with no restrictions, would be a function of the
number of the pieces on the board and the maximum number of moves (4). However
as per the rules of the game, 192 moves occur before the board shrinks for the
second time. After this there would be a limited number of moves left which
are dependent on the aforementioned factors. We chose 500 to be the maximum
search depth, allowing the search algorithm to run for at least the suggested
30 seconds.

The A* algorithm will find the shortest path given an admissible heuristic
We make use of the Manhattan distance which is admissible since it always
underestimates the distance between two board positions, by not accounting
for the possibility of jumping. However our algorithm does not always return
the shortest possible path to eliminate all enemy pieces as it does not
account for the possible elimination of white pieces. As such, it may
occasionally move a white piece into a position where it would be instantly
eliminated. However if it does manage to find a solution where no white pieces
are eliminated, this would in fact return the shortest possible sequence of
moves that eliminates all enemy pieces.

###############################################################################
